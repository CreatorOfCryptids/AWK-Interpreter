import java.util.LinkedList;
import java.util.Optional;

public class Parser {

    TokenHandler h;
    ProgramNode pNode;

    Parser(LinkedList<Token> tokens){
        h = new TokenHandler(tokens);
        pNode = new ProgramNode();
    }

    /**
     * The parse() method.
     * @return the ProgramNode generated by the inputed LinkedList of Tokens.
     */
    public ProgramNode parse() throws Exception{
        // Loop calling two functions, parseFunction() and parseAction().
        while (h.moreTokens()){
            h.acceptSeperators();
            if (parseFunction(pNode)){}
        
            else if (parseAction(pNode)){}

            else
                throw new Exception("Issue Parsing.");
            // If both are false, throw an exception
        }
        
        return pNode;
    }

    /**
     * The parseFunction() method.
     * @param node
     * @return True if there is a function, False if not.
     */
    boolean parseFunction(ProgramNode node) throws Exception{
        // See if the expression is a function. If its not a funcition return false.
        if (h.matchAndRemove(Token.Type.FUNCTION).isEmpty()){
            return false;
        }
        else{
            // Initialize variables to pass to the FunctionDefinitionNode constructor.
            String name; 
            LinkedList<String> parameters = new LinkedList<String>();
            LinkedList<StatementNode> statements = new LinkedList<StatementNode>();

            h.acceptSeperators();

            // Take in name, if its missing throw an exception.
            if (h.peek().get().getType() == Token.Type.STRINGLITERAL)
                name = h.matchAndRemove(Token.Type.STRINGLITERAL).get().getValue();
            else
                throw new Exception("Expected a name for the function.");

            // Take in the '(' and throw an exception if it is not there.
            if (h.matchAndRemove(Token.Type.LPAREN).isEmpty())
                throw new Exception("Expected a '(' after the " + name + " function declaration.");

            // Take in the parameters, until there is a ')'
            while (h.matchAndRemove(Token.Type.RPAREN).isEmpty()){
                parameters.add(h.matchAndRemove(Token.Type.STRINGLITERAL).get().getValue());
                h.matchAndRemove(Token.Type.COMMA);
                h.acceptSeperators();
            }
            // Take in the '{' or throw an exception.
            if (h.matchAndRemove(Token.Type.LCURLY).isEmpty()){
                throw new Exception("Expected a '{' after the " + name + "function declaration.");
            }
            // Take in the statments
            while (h.matchAndRemove(Token.Type.RCURLY).isEmpty()) {
                Optional<StatementNode> statement = parseStatement();
                if (statement.isPresent())
                    statements.add(statement.get());
            }
            // Initalize the FunctionDefinionNode and add to the ProgramNode.
            pNode.add(new FunctionDefinitionNode(name, parameters, null));
            return true;
        }
    }

    /**
     * The parseFunction() method.
     * @param node
     * @return True if the fucntion can add an action to the node, False if not.
     */
    boolean parseAction(ProgramNode node){
        //ToDo move the selection of which block to alocate to after we know what the condition looks like.
        if (h.matchAndRemove(Token.Type.BEGIN).isPresent()){
            node.addBeginBlock(parseBlock());
        }
        else if (h.matchAndRemove(Token.Type.END).isPresent()){
            node.addEndBlock(parseBlock());
        }
        else {
            parseOperation();
            parseBlock();
        }
        return true;
    }

    /**
     * The parseBlock() method.
     * @return BlockNode created from the token stream
     */
    private BlockNode parseBlock(){

        return null;
    }
    
    /**
     * The parseOperation() method.
     * @return Operation that operates to T/F
     */
    private Optional<Node> parseOperation(){
        return Optional.empty();
    }

    /**
     * The parseStatement() method.
     * @return StatementNode made from the token stream.
     */
    private Optional<StatementNode> parseStatement(){
        return Optional.empty();
    }
}
