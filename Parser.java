import java.util.LinkedList;
import java.util.Optional;

public class Parser {

    TokenHandler h;
    ProgramNode pNode;

    /**
     * The Parser constructor.
     * @param tokens A LinkedList of Token to be parsed.
     */
    Parser(LinkedList<Token> tokens){
        h = new TokenHandler(tokens);
        pNode = new ProgramNode();
    }

    /**
     * The parse() method.
     * @return the ProgramNode generated by the inputed LinkedList of Tokens.
     */
    public ProgramNode parse() throws Exception{
        // Loop calling two functions, parseFunction() and parseAction().
        while (h.moreTokens()){
            acceptSeperators();
            if (parseFunction(pNode)){}
            else if (parseAction(pNode)){}
            //* There's a bug that causes an infinite loop if you add an extra '}' at the end of the input, and I was trying to fix it.
            else if (h.matchAndRemove(Token.Type.RCURLY).isPresent())
                throw new Exception("Unexpected '}' found at " + h.getErrorPosition());
            //*/
            else
                throw new Exception("Issue parsing after " + h.getErrorPosition());
            // If both return false, throw an exception
        }
        return pNode;
    }

    /**
     * The acceptSeperators() method
     * @return True if there is one or more seperators, false if else.
     */
    private boolean acceptSeperators(){
        boolean existsSeperators = false;
        while (h.moreTokens() && h.matchAndRemove(Token.Type.SEPERATOR).isPresent())
            existsSeperators = true;
        return existsSeperators;
    }

    /**
     * The parseFunction() method.
     * @param node
     * @return True if there is a function, False if not.
     */
    boolean parseFunction(ProgramNode node) throws Exception{
        // See if the expression is a function. If its not a funcition return false.
        if (h.matchAndRemove(Token.Type.FUNCTION).isEmpty()){
            return false;
        }
        else{
            // Initialize variables to pass to the FunctionDefinitionNode constructor.
            String name; 
            LinkedList<String> parameters = new LinkedList<String>();
            LinkedList<StatementNode> statementList;

            acceptSeperators();

            // Take in name, if it's missing throw an exception.
            if (h.peek().get().getType() == Token.Type.WORD)
                name = h.matchAndRemove(Token.Type.WORD).get().getValue();
            else
                throw new Exception("Expected a name for the function.");

            // Take in the '(' and throw an exception if it is not there.
            if (h.matchAndRemove(Token.Type.LPAREN).isEmpty())
                throw new Exception("Expected a '(' after the " + name + " function declaration at " + h.getErrorPosition());

            // Take in the parameters, until there is a ')'
            while (h.matchAndRemove(Token.Type.RPAREN).isEmpty()){
                parameters.add(h.matchAndRemove(Token.Type.WORD).get().getValue());
                h.matchAndRemove(Token.Type.COMMA);
                acceptSeperators();
            }
            acceptSeperators();
            // Take in the statments
            statementList = parseStatements();
            // Initalize the FunctionDefinionNode and add to the ProgramNode.
            pNode.add(new FunctionDefinitionNode(name, parameters, statementList));
            return true;
        }
    }

    /**
     * The parseAction() method.
     * @param node
     * @return True if there is a parseable action, false if not.
     */
    boolean parseAction(ProgramNode node)throws Exception{
        // Check for BEGIN and END
        if (h.matchAndRemove(Token.Type.BEGIN).isPresent()){
            node.addBeginBlock(parseBlock());
            return true;
        }
        else if (h.matchAndRemove(Token.Type.END).isPresent()){
            node.addEndBlock(parseBlock());
            return true;
        }
        else {
            node.addOtherBlock(parseBlock());
            return true;
        }
        //return false;
    }

    /**
     * The parseBlock() method.
     * @return BlockNode created from the token stream
     */
    private BlockNode parseBlock() throws Exception{
        // Take in the operation. If there was a Begin or END statement, this will just skip to the statements.
        Optional<Node> condition = parseOperation();
        LinkedList<StatementNode> statementList = new LinkedList<StatementNode>();
        statementList = parseStatements();
        return new BlockNode(condition, statementList);
    }

    /**
     * The parseStatements() method.
     * @return A LinkedList of Optional<StatementNode>.
     */
    private LinkedList<StatementNode> parseStatements() throws Exception{
        LinkedList<StatementNode> statementList = new LinkedList<StatementNode>();
        // Loop until there's a '}'
        if (h.matchAndRemove(Token.Type.LCURLY).isPresent())
            while (h.matchAndRemove(Token.Type.RCURLY).isEmpty()) {
                // Make sure there's still more tokens
                if (!h.moreTokens())
                    throw new Exception("Expected a closing '}' after " + h.getErrorPosition());
                // Parse the next statement and add to the list.
                Optional<StatementNode> statement = parseStatement();
                if (statement.isPresent())
                    statementList.add(statement.get());
            }
        else {
            Optional<StatementNode> temp = parseStatement();
            if (temp.isPresent())
                statementList.add(temp.get());
            
        }
        acceptSeperators();
        return statementList;
    }

    /**
     * The parseStatement() method.
     * @return StatementNode made from the token stream.
     */
    private Optional<StatementNode> parseStatement()throws Exception{
        Optional<StatementNode> returnStatement;
        acceptSeperators();
        if(h.matchAndRemove(Token.Type.IF).isPresent())
            // This looks really wonky, but I needed to do this to ensure type safety
            returnStatement = Optional.of(parseIf().get());
        else if(h.matchAndRemove(Token.Type.FOR).isPresent())
            returnStatement = parseFor();
        else if(h.matchAndRemove(Token.Type.WHILE).isPresent())
            returnStatement = parseWhile();
        else if(h.matchAndRemove(Token.Type.DO).isPresent())
            returnStatement = parseDoWhile();
        else if(h.matchAndRemove(Token.Type.RETURN).isPresent())
            returnStatement = parseReturn();
        else if(h.matchAndRemove(Token.Type.DELETE).isPresent())
            returnStatement = parseDelete();
        else if(h.matchAndRemove(Token.Type.BREAK).isPresent()){
            var bn = new BreakNode();
            returnStatement = Optional.of(bn);
        }
        else if(h.matchAndRemove(Token.Type.CONTINUE).isPresent()){
            var cn = new ContinueNode();
            returnStatement = Optional.of(cn);
        }
        else{
            var returnedOperation = parseOperation();
            // Make sure that it is an assignment node.
            if (returnedOperation.isPresent() && returnedOperation.get() instanceof StatementNode)
                returnStatement = Optional.of((StatementNode) returnedOperation.get());
            else
                return Optional.empty();
        }
        return returnStatement;
    }

    /**
     * The parseIf() method.
     * @return an IfNode containing a parsed if statement.
     */
    private Optional<IfNode> parseIf()throws Exception{
        
        if (h.matchAndRemove(Token.Type.LPAREN).isEmpty())
            throw new Exception("Expected a '(' after " +  h.getErrorPosition());

        Optional<Node> optNode = parseOperation(); 
        if (optNode.isEmpty())
            throw new Exception("Expected an operation at or before " + h.getErrorPosition());
        Node condition = optNode.get();

        // Make sure there's a closing parenthesis when expected.
        if (h.matchAndRemove(Token.Type.RPAREN).isEmpty())
            throw new Exception("Expected a ')' after " + h.getErrorPosition());
        // Swallow any newlines.
            acceptSeperators();
        
        LinkedList<StatementNode> statements = parseStatements();

        // Initialize the IfNode pointer outside so we can decide whether to add else statements.
        IfNode returnIfNode;
        // Check for elseif and else statements
        if (h.matchAndRemove(Token.Type.ELSE).isPresent())
            // If there is an if statement after the else, then pass the recursivly called parseIf() to the else if constructor.
            if (h.matchAndRemove(Token.Type.IF).isPresent())
                returnIfNode = new IfNode(condition, statements, parseIf().get());
            // If there is not an if, then just take it as a list of statements and pass that to the else constructor
            else
                returnIfNode = new IfNode(parseStatements());
        else
            returnIfNode = new IfNode(condition, statements);
        
        return Optional.of(returnIfNode);
    }
    
    /**
     * The parseFor() method.
     * @return either a parsed ForNode or parsed ForEachNode.
     * @throws Exception
     */
    private Optional<StatementNode> parseFor() throws Exception{
        if (h.matchAndRemove(Token.Type.LPAREN).isEmpty())
            throw new Exception("Expected a '(' after " + h.getErrorPosition());
        
        // Check to see if the key word "in" is inside the parentheses.
        boolean foundIn = false;
        for(int i=1; (h.moreTokens() && (h.peek(i).get().getType() != Token.Type.RPAREN)); i++)
            if (h.peek(i).isEmpty())
                throw new Exception("Expected a ')' after " + h.getErrorPosition());
            else if (h.peek(i).get().getType() == Token.Type.IN){
                foundIn = true;
                break;
            }
        
        if (foundIn){ // If there is an IN token inside the parenthesis, then it's a ForEachNode.
            ForEachNode retval;

            // Make sure that the iterator is a valid variable reference.
            var retNode = parseLValue().get();
            if (!(retNode instanceof VariableReferenceNode))
                throw new Exception("Expected a valid variable name at " + h.getErrorPosition());
            VariableReferenceNode iterator = (VariableReferenceNode) retNode;

            // Make sure that there is the "in" token.
            if (h.matchAndRemove(Token.Type.IN).isEmpty())
                throw new Exception("Expected the 'in' token after " + h.getErrorPosition());

            // Make sure that the iteratable is a valid variable reference.
            retNode = parseLValue().get();
            if (!(retNode instanceof VariableReferenceNode))
                throw new Exception("Expected a valid variable name at " + h.getErrorPosition());
            VariableReferenceNode iteratable = (VariableReferenceNode) retNode;

            if(h.matchAndRemove(Token.Type.RPAREN).isEmpty())
                throw new Exception("Expected a ')' after " +  h.getErrorPosition());
            // Swallow any newlines.
            acceptSeperators();

            retval = new ForEachNode(iterator, iteratable, parseStatements());
            return Optional.of(retval);
        }
        else{ // Otherwize it's a for node.
            ForNode retval;

            Node initiation, condition, iteration;

            // Take in the three operations.
            initiation = parseOperation().get();
            acceptSeperators();
            condition = parseOperation().get();
            acceptSeperators();
            iteration = parseOperation().get();

            if(h.matchAndRemove(Token.Type.RPAREN).isEmpty())
                throw new Exception("Expected a ')' after " +  h.getErrorPosition()); 
            
            // Swallow any newlines.
            acceptSeperators();

            retval = new ForNode(initiation, condition, iteration, parseStatements());

            return Optional.of(retval);
        }
    }

    /**
     * The parseWhile method.
     * @return the parsed While Loop.
     * @throws Exception
     */
    private Optional<StatementNode> parseWhile()throws Exception{
        if (h.matchAndRemove(Token.Type.LPAREN).isEmpty())
            throw new Exception("Expected a '(' after " + h.getErrorPosition());
        
        // Take in the condition, and make sure it's valid.
        Optional<Node> returnedOperation = parseOperation(); 
        if (returnedOperation.isEmpty())
            throw new Exception("Expected an operation at or before " + h.getErrorPosition());
        Node condition = returnedOperation.get();

        // Make sure there's a closing parenthesis when expected.
        if (h.matchAndRemove(Token.Type.RPAREN).isEmpty())
            throw new Exception("Expected a ')' after " + h.getErrorPosition());
        // Swallow any newlines.
        acceptSeperators();
        
        WhileNode retval = new WhileNode(condition, parseStatements());
        return Optional.of(retval);
    }

    /**
     * The parseDoWhile() method.
     * @return A parsed DoWhile Loop.
     * @throws Exception
     */
    private Optional<StatementNode> parseDoWhile()throws Exception{
        LinkedList<StatementNode> statements = parseStatements();
        acceptSeperators();

        if (h.matchAndRemove(Token.Type.WHILE).isEmpty())
            throw new Exception("Expected a WHILE token after " + h.getErrorPosition());

        if (h.matchAndRemove(Token.Type.LPAREN).isEmpty())
            throw new Exception("Expected a '(' after " + h.getErrorPosition());
        
        // Take in the condition, and make sure it's valid.
        Optional<Node> returnedOperation = parseOperation(); 
        if (returnedOperation.isEmpty())
            throw new Exception("Expected an operation at or before " + h.getErrorPosition());
        Node condition = returnedOperation.get();

        // Make sure there's a closing parenthesis when expected.
        if (h.matchAndRemove(Token.Type.RPAREN).isEmpty())
            throw new Exception("Expected a ')' after " + h.getErrorPosition());

        DoWhileNode retval = new DoWhileNode(condition, statements);
        return Optional.of(retval);
    }

    /**
     * The parseReturn() method.
     * @return A parsed ReturnNode.
     * @throws Exception
     */
    private Optional<StatementNode> parseReturn()throws Exception{
        ReturnNode retval = new ReturnNode(parseOperation().get());
        return Optional.of(retval);
    }

    /**
     * The parseDelete() method.
     * @return A parsed DeleteNode.
     * @throws Exception
     */
    private Optional<StatementNode> parseDelete()throws Exception{
        Node lValue = parseLValue().get();

        // Make sure it is the right kind of node.
        if (!(lValue instanceof VariableReferenceNode))
            throw new Exception("Expected a variable at " + h.getErrorPosition());
        VariableReferenceNode variableNode = (VariableReferenceNode) lValue;

        DeleteNode retval = new DeleteNode(variableNode);
        return Optional.of(retval);
    }

    /**
     * The parseFunctionCall() method.
     * @return
     * @throws Exception
     */
    private Optional<StatementNode> parseFunctionCall()throws Exception{
        String name = h.matchAndRemove(Token.Type.WORD).get().getValue();

        h.matchAndRemove(Token.Type.LPAREN);    // Already checked for the '(' before calling the parseFunctionCall().

        LinkedList<Node> parameters = new LinkedList<>();
        // This should not be replaced with parseStatements, because this takes parameters, not statements.
        while(h.moreTokens() && h.matchAndRemove(Token.Type.RPAREN).isEmpty()){
            parameters.add(parseOperation().get());
            // If there isn't a comma after a parameter, then the next token should be an RPAREN.
            if(h.matchAndRemove(Token.Type.COMMA).isEmpty())
                if(h.moreTokens() && h.peek().get().getType() != Token.Type.RPAREN)
                    throw new Exception("Expected a ')' after " + h.getErrorPosition());
        }

        FunctionCallNode retval = new FunctionCallNode(name, parameters);
        return Optional.of(retval);
    }

    /**
     * The parseOperation() method.
     * @return an Optional node containing an operation.
     */
    private Optional<Node> parseOperation() throws Exception{
        return parseAssignment();
    }

    /**
     * The parseAssignment() method.
     * @return A detected assignment node, or the results of parseTeranary
     * @throws Exception
     */
    private Optional<Node> parseAssignment() throws Exception{
        // parseTernary will either return a Ternary node or a node from a lower level, so 
        Optional<Node> left = parseTernary();
        // Check if it follows the assignment pattern
        if (h.matchAndRemove(Token.Type.EXPONENTEQUALS).isPresent()){
            AssignmentNode retval = new AssignmentNode(left.get(), new OperationNode(left.get(), OperationNode.Operation.EXPONENT, parseMathExpression().get()));
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.MODEQUALS).isPresent()){
            AssignmentNode retval = new AssignmentNode(left.get(), new OperationNode(left.get(), OperationNode.Operation.MODULO, parseMathExpression().get()));
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.TIMESEQUALS).isPresent()){
            AssignmentNode retval = new AssignmentNode(left.get(), new OperationNode(left.get(), OperationNode.Operation.MULTIPLY, parseMathExpression().get()));
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.DIVIDEEQUALS).isPresent()){
            AssignmentNode retval = new AssignmentNode(left.get(), new OperationNode(left.get(), OperationNode.Operation.DIVIDE, parseMathExpression().get()));
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.PLUSEQUALS).isPresent()){
            AssignmentNode retval = new AssignmentNode(left.get(), new OperationNode(left.get(), OperationNode.Operation.ADD, parseMathExpression().get()));
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.MINUSEQUALS).isPresent()){
            AssignmentNode retval = new AssignmentNode(left.get(), new OperationNode(left.get(), OperationNode.Operation.SUBTRACT, parseMathExpression().get()));
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.EQUALS).isPresent()){
            AssignmentNode retval = new AssignmentNode(left.get(), parseTernary().get());
            return Optional.of(retval);
        }
        else if (h.moreTokens() && (h.peek().get().getType() == Token.Type.STRINGLITERAL || h.peek().get().getType() == Token.Type.WORD)){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.CONCATENATION, parseTernary().get());
            return Optional.of(retval);
        }
        // If it doesn't follow the assignment pattern, just return left.
        else{
            return left;
        }
    }

    /**
     * The parseTernary() method.
     * @return A TernaryNode or the next layer down if it doesn't follow the ternary pattern.
     * @throws Exception
     */
    private Optional<Node> parseTernary() throws Exception {
        // Look for the starting boolean expression.
        Optional<Node> boolValue = parseOrLogic();
        // If there is no question mark, then it doesn't follow the pattern. Return the next layer down.
        if (h.matchAndRemove(Token.Type.QUESTIONMARK).isEmpty()){
            return boolValue;
        }
        else{
            Optional<Node> trueCase = parseOperation();
            // It has to follow the ternary pattern, so if it doesn't, throw an error.
            if (h.matchAndRemove(Token.Type.COLON).isEmpty())
                throw new Exception("Expected a ':' after " + h.getErrorPosition());
            Optional<Node> falseCase = parseOperation();
            var retval = new TernaryNode(boolValue.get(), trueCase.get(), falseCase.get());
            return Optional.of(retval);
        }
    }

    /**
     * The parseOrLogic() method.
     * @return An OperationNode with an OR operator, or the next layer down.
     * @throws Exception
     */
    private Optional<Node> parseOrLogic() throws Exception {
        Optional<Node> left = parseAndLogic();
        // If it follows the pattern, make an OR node, if not, return the next layer down.
        if (h.matchAndRemove(Token.Type.OR).isPresent()) {
            var retval = new OperationNode(left.get(), OperationNode.Operation.OR, parseAndLogic().get());
            return Optional.of(retval);
        }
        else 
            return left;
    }

    /**
     * The parseAndLogic() method.
     * @return Returns an OperationNode with an AND operator, or the results from the next layer down.
     * @throws Exception
     */
    private Optional<Node> parseAndLogic() throws Exception {
        Optional<Node> left = parseBoolean();
        if (h.matchAndRemove(Token.Type.AND).isPresent()){
            var retval = new OperationNode(left.get(), OperationNode.Operation.AND, parseBoolean().get());
            return Optional.of(retval);
        }
        else 
            return left;
    }

    /**
     * The parseBoolean() method.
     * @return Returns an OperationNode with a found boolean Expression, or the results from the next layer down.
     * @throws Exception
     */
    private Optional<Node> parseBoolean() throws Exception {
        // Only the results of parseMathExpression() can start a boolean expression.
        Optional<Node> left = parseMathExpression();
        // Check for the right patterns.
        if (h.matchAndRemove(Token.Type.GREATER).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.GT, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.GREATEREQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.GE, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.NOTEQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.NE, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.EQUALSEQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.EQ, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.LESS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.LT, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.LESSEQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.LE, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.MATCH).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.MATCH, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if(h.matchAndRemove(Token.Type.NOTMATCH).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.NOTMATCH, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else 
            return left;
    }

    /**
     * The parseMathExpression() method.
     * @return An OperationNode containing an add or subtract operator, or the results from the next layer down.
     * @throws Exception
     */
    private Optional<Node> parseMathExpression() throws Exception{
        Optional<Node> retval = parseMathTerm();
        // Repeat catching '+' and '-' to make sure that you catch multiple terms in a row.
        while (h.moreTokens() && (h.peek().get().getType() == Token.Type.PLUS || h.peek().get().getType() == Token.Type.MINUS)){
            if (h.matchAndRemove(Token.Type.PLUS).isPresent()){
                OperationNode retnode = new OperationNode(retval.get(), OperationNode.Operation.ADD, parseMathTerm().get());
                retval = Optional.of(retnode);
                //return Optional.of(retval);
            }   
            else if (h.matchAndRemove(Token.Type.MINUS).isPresent()){
                /*var retval = new OperationNode(left.get(), OperationNode.Operation.SUBTRACT, parseMathTerm().get());
                return Optional.of(retval);*/
                OperationNode retnode = new OperationNode(retval.get(), OperationNode.Operation.SUBTRACT, parseMathTerm().get());
                retval = Optional.of(retnode);
            }
        }
        
        return retval;
    }

    /**
     * The parseMathTerm() method.
     * @return an OperationNode containing a multiplication, division, or modulo operator, or the results from the next layer down.
     * @throws Exception
     */
    private Optional<Node> parseMathTerm() throws Exception{
        Optional<Node> left = parseMathPower();
        if (h.matchAndRemove(Token.Type.ASTRIC).isPresent()){
            var retval = new OperationNode(left.get(), OperationNode.Operation.MULTIPLY, parseMathPower().get());
            return Optional.of(retval);
        }   
        else if (h.matchAndRemove(Token.Type.SLASH).isPresent()){
            var retval = new OperationNode(left.get(), OperationNode.Operation.DIVIDE, parseMathPower().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.MOD).isPresent()){
            var retval = new OperationNode(left.get(), OperationNode.Operation.MODULO, parseMathPower().get());
            return Optional.of(retval); 
        }
        else
            return left;
    }

    /**
     * The parseMathPower() method.
     * @return an OperationNode containing an exponent operator, or the results from the next layer down.
     * @throws Exception
     */
    private Optional<Node> parseMathPower() throws Exception{
        Optional<Node> left = parseBottomLevel();
        if (h.matchAndRemove(Token.Type.EXPONENT).isPresent()){
            // We call parseMathPower() recursively here because exponents are right associative.
            var retval = new OperationNode(left.get(), OperationNode.Operation.EXPONENT, parseMathPower().get());   
            return Optional.of(retval);
        }
        else
            return left;
    }

    /**
     * The parseBottomLevel() method. (Factor)
     * @return A ConstantNode containing a detected string or number; a PatternNode containting a detected pattern;
     *  or an OperationNode contatining a detected operation or urinary operator
     * @throws Exception
     */
    private Optional<Node> parseBottomLevel() throws Exception{
        // Since we need to make sure they're the right type before we consume them, we use peek() instead of /
        // matchAndRemove() for STRINGLITERALs, NUMERs and PATTERNs.
        Node retval;
        if (h.moreTokens() && h.peek().get().getType() == Token.Type.STRINGLITERAL) {
            retval = new ConstantNode(h.matchAndRemove(Token.Type.STRINGLITERAL).get());
        }
        else if (h.moreTokens() && h.peek().get().getType() == Token.Type.NUMBER){
            retval = new ConstantNode(h.matchAndRemove(Token.Type.NUMBER).get());
        }
        else if (h.moreTokens() && h.peek().get().getType() == Token.Type.PATTERN){
            //throw new Exception("It was doing pattern, suck it ");
            retval = new PatternNode(h.matchAndRemove(Token.Type.PATTERN).get());
        }
        // We can use match and remove for the rest.
        // The nested functions are a bit different in that we are calling parse operation (kinda) recursivly
        else if (h.matchAndRemove(Token.Type.LPAREN).isPresent()){
            retval = parseOperation().get();

            if (h.matchAndRemove(Token.Type.RPAREN).isEmpty())
                throw new Exception("Expected a ')' at " + h.getErrorPosition());
            // Don't need to put this one in an Optional because parseOperation already does that for us.
        }
        else if (h.matchAndRemove(Token.Type.NOT).isPresent()){
            retval = new OperationNode(parseOperation().get(), OperationNode.Operation.NOT);
        }
        else if (h.matchAndRemove(Token.Type.MINUS).isPresent()){
            retval = new OperationNode(parseOperation().get(), OperationNode.Operation.UNARYNEG);
        }
        else if (h.matchAndRemove(Token.Type.PLUS).isPresent()){
            retval = new OperationNode(parseOperation().get(), OperationNode.Operation.UNARYPOS);
        }
        else if (h.matchAndRemove(Token.Type.PLUSPLUS).isPresent()){
            Node temp = parseBottomLevel().get();
            retval = new OperationNode(temp, OperationNode.Operation.PREINC);
            retval = new AssignmentNode(temp, retval);
        }
        else if (h.matchAndRemove(Token.Type.MINUSMINUS).isPresent()){
            Node temp = parseBottomLevel().get();
            retval = new OperationNode(temp, OperationNode.Operation.PREDEC);
            retval = new AssignmentNode(temp, retval);
        }
        else if (((h.moreTokens() && h.peek(1).isPresent()) && (h.peek().get().getType() == Token.Type.WORD && h.peek(1).get().getType() == Token.Type.LPAREN)))
            retval = parseFunctionCall().get();
        else{// If it's none of the above, then it must be a variable.
            Optional<Node> temp = parseLValue();
            if (temp.isPresent())
                retval = temp.get();
            else 
                return Optional.empty();
        }
        //check for postinc and postdec, and put them into AssignmentNodes
        if (h.matchAndRemove(Token.Type.PLUSPLUS).isPresent()){
            Node temp = new OperationNode(retval, OperationNode.Operation.POSTINC);
            retval = new AssignmentNode(retval, temp);
        }
        else if (h.matchAndRemove(Token.Type.MINUSMINUS).isPresent()){
            Node temp = new OperationNode(retval, OperationNode.Operation.POSTDEC);
            retval = new AssignmentNode(retval, temp);
        }

        return Optional.of(retval);
    }

    /**
     * The parseLValue() method. (Variable)
     * @return A VariableReferenceNode containing a valid variable, array variable, or the outcome of a $ operator.
     * @throws Exception
     */
    private Optional<Node> parseLValue() throws Exception{
        // Checks if there are more tokens.
        if (h.moreTokens()){
            // if its not a dollar, we want to be able to check it without eating it.
            Optional<Token> next = h.peek();
            // If it is a dollar, pass it to parseBottomLevel()
            if(h.matchAndRemove(Token.Type.DOLLAR).isPresent()){
                OperationNode temp = new OperationNode(parseBottomLevel().get(), OperationNode.Operation.DOLLAR);
                return Optional.of(temp);
            }
            else if (next.get().getType() == Token.Type.WORD){
                // Get the next word and sotore as the name
                String name = h.matchAndRemove(Token.Type.WORD).get().getValue();
                // Check for array entry and parse with parseOperation().
                if(h.matchAndRemove(Token.Type.LSQUARE).isPresent()){
                    Optional<Node> index = parseOperation();
                    // If there's no closing bracket, thow a fit.
                    if (h.matchAndRemove(Token.Type.RSQUARE).isEmpty())
                        throw new Exception("Expected a ']' near " + name + " after " + h.getErrorPosition() + ".");
                    
                    VariableReferenceNode temp = new VariableReferenceNode(name, index.get());
                    return Optional.of(temp);
                }
                else{
                    VariableReferenceNode temp = new VariableReferenceNode(name);
                    return Optional.of(temp);
                }
            }
            else 
                return Optional.empty();
        }
        else
            throw new Exception("Expected a token after " + h.getErrorPosition());
    }
}