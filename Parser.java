import java.util.LinkedList;
import java.util.Optional;

public class Parser {

    TokenHandler h;
    ProgramNode pNode;

    /**
     * The Parser constructor.
     * @param tokens A LinkedList of Token to be parsed.
     */
    Parser(LinkedList<Token> tokens){
        h = new TokenHandler(tokens);
        pNode = new ProgramNode();
    }

    /**
     * The parse() method.
     * @return the ProgramNode generated by the inputed LinkedList of Tokens.
     */
    public ProgramNode parse() throws Exception{
        // Loop calling two functions, parseFunction() and parseAction().
        while (h.moreTokens()){
            acceptSeperators();
            if (parseFunction(pNode)){}
            else if (parseAction(pNode)){}
            else
                throw new Exception("Issue parsing after " + h.getErrorPosition());
            // If both return false, throw an exception
        }
        return pNode;
    }

    /**
     * The acceptSeperators() method
     * @return True if there is one or more seperators, false if else.
     */
    private boolean acceptSeperators(){
        boolean existsSeperators = false;
        while (h.moreTokens() && h.matchAndRemove(Token.Type.SEPERATOR).isPresent())
            existsSeperators = true;
        return existsSeperators;
    }

    /**
     * The parseFunction() method.
     * @param node
     * @return True if there is a function, False if not.
     */
    boolean parseFunction(ProgramNode node) throws Exception{
        // See if the expression is a function. If its not a funcition return false.
        if (h.matchAndRemove(Token.Type.FUNCTION).isEmpty()){
            return false;
        }
        else{
            // Initialize variables to pass to the FunctionDefinitionNode constructor.
            String name; 
            LinkedList<String> parameters = new LinkedList<String>();
            LinkedList<StatementNode> statementList;

            acceptSeperators();

            // Take in name, if its missing throw an exception.
            if (h.peek().get().getType() == Token.Type.WORD)
                name = h.matchAndRemove(Token.Type.WORD).get().getValue();
            else
                throw new Exception("Expected a name for the function.");

            // Take in the '(' and throw an exception if it is not there.
            if (h.matchAndRemove(Token.Type.LPAREN).isEmpty())
                throw new Exception("Expected a '(' after the " + name + " function declaration at " + h.getErrorPosition());

            // Take in the parameters, until there is a ')'
            while (h.matchAndRemove(Token.Type.RPAREN).isEmpty()){
                parameters.add(h.matchAndRemove(Token.Type.WORD).get().getValue());
                h.matchAndRemove(Token.Type.COMMA);
                acceptSeperators();
            }
            acceptSeperators();
            // Take in the '{' or throw an exception.
            if (h.matchAndRemove(Token.Type.LCURLY).isEmpty()){
                throw new Exception("Expected a '{' after the " + name + " function declaration at " + h.getErrorPosition());
            }
            // Take in the statments
            statementList = parseStatements();
            // Initalize the FunctionDefinionNode and add to the ProgramNode.
            pNode.add(new FunctionDefinitionNode(name, parameters, statementList));
            return true;
        }
    }

    /**
     * The parseFunction() method.
     * @param node
     * @return True if the fucntion can add an action to the node, False if not.
     */
    boolean parseAction(ProgramNode node)throws Exception{
        // Check for BEGIN and END
        if (h.matchAndRemove(Token.Type.BEGIN).isPresent()){
            node.addBeginBlock(parseBlock());
        }
        else if (h.matchAndRemove(Token.Type.END).isPresent()){
            node.addEndBlock(parseBlock());
        }
        else {
            node.addOtherBlock(parseBlock());
        }
        return true;
    }

    /**
     * The parseBlock() method.
     * @return BlockNode created from the token stream
     */
    private BlockNode parseBlock() throws Exception{
        // Take in the operation. If there was a Begin or END statement, this will just skip to the statements.
        Optional<Node> condition;
        if (h.matchAndRemove(Token.Type.LCURLY).isEmpty())
            condition = parseOperation();
        else 
            condition = Optional.empty();
        LinkedList<StatementNode> statementList = parseStatements();
        return new BlockNode(condition, statementList);
    }
    
    /**
     * The parseOperation() method.
     * @return Operation that operates to T/F
     */
    public Optional<Node> parseOperation() throws Exception{
        /*
        while(h.moreTokens() && h.matchAndRemove(Token.Type.LCURLY).isEmpty()){
            h.matchAndRemove(h.peek().get().getType());
        }/**/
        Optional<Node> left = parseBottomLevel();
        if (left.isEmpty())
            throw new Exception("The left node cannot be null");
        if (h.matchAndRemove(Token.Type.PLUSPLUS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.POSTINC);
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.MINUSMINUS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.POSTDEC);
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.ASTRIC).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.MULTIPLY, parseOperation().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.SLASH).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.DIVIDE, parseOperation().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.MOD).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.MODULO, parseOperation().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.PLUS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.ADD, parseOperation().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.MINUS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.SUBTRACT, parseOperation().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.LESS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.LT, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.LESSEQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.LE, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.EQUALSEQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.EQ, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.NOTEQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.NE, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.GREATER).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.GT, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.GREATEREQUALS).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.GE, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.MATCH).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.MATCH, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.NOTMATCH).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.NOTMATCH, parseBottomLevel().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.AND).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.AND, parseOperation().get());
            return Optional.of(retval);
        }
        else if (h.matchAndRemove(Token.Type.OR).isPresent()){
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.OR, parseOperation().get());
            return Optional.of(retval);
        }
        // TODO still need to implement the assignments and exponents.
        else if (h.matchAndRemove(Token.Type.QUESTIONMARK).isPresent()){
            var trueCase = parseOperation().get();
            if(h.matchAndRemove(Token.Type.COLON).isEmpty())
                throw new Exception("Expected a ':' after " + h.getErrorPosition());
            var retval = new TernaryNode(left.get(), trueCase, parseOperation().get());
            return Optional.of(retval);
        }
        else if (h.moreTokens() && (h.peek().get().getType() == Token.Type.WORD || h.peek().get().getType() == Token.Type.STRINGLITERAL)) {
            Node right = parseBottomLevel().get();
            OperationNode retval = new OperationNode(left.get(), OperationNode.Operation.CONCATENATION, right);
            return Optional.of(retval);
        }
        //else if (acceptSeperators() == true){
        return left;
        /*}
        else
            throw new Exception("");
        /**/
    }

    /**
     * The parseStatements() method.
     * @return A LinkedList of Optional<StatementNode>.
     */
    private LinkedList<StatementNode> parseStatements() throws Exception{
        LinkedList<StatementNode> statementList = new LinkedList<StatementNode> ();
        // Loop until there's a '}'
        while (h.matchAndRemove(Token.Type.RCURLY).isEmpty()) {
            // Make sure there's still more tokens
            if (!h.moreTokens())
                throw new Exception("Expected a closing '}' after " + h.getErrorPosition());
            // Parse the next statement and add to the list.
            Optional<StatementNode> statement = parseStatement();
            if (statement.isPresent())
                statementList.add(statement.get());
        }
        return statementList;
    }

    /**
     * The parseStatement() method.
     * @return StatementNode made from the token stream.
     */
    private Optional<StatementNode> parseStatement(){
        // Just to let it take in things, i know this kinda goes against the whole reason that we dont have a function to explicityly \
        // do this, but it allows testing.
        //TODO Don't keep this please, future me.
        while (acceptSeperators() == false && h.peek().get().getType() != Token.Type.RCURLY){
            h.matchAndRemove(h.peek().get().getType());
        }
        return Optional.empty();
    }

    /**
     * The parseBottomLevel() method.
     * @return A ConstantNode containing a detected string or number; a PatternNode containting a detected pattern;
     *  or an OperationNode contatining a detected operation or urinary operator
     * @throws Exception
     */
    private Optional<Node> parseBottomLevel() throws Exception{
        // Since we need to make sure they're the right type before we consume them, we use peek() instead of /
        // matchAndRemove() for STRINGLITERALs, NUMERs and PATTERNs.
        if (h.peek().get().getType() == Token.Type.STRINGLITERAL) {
            ConstantNode temp = new ConstantNode(h.matchAndRemove(Token.Type.STRINGLITERAL).get());
            return Optional.of(temp);
        }
        else if (h.peek().get().getType() == Token.Type.NUMBER){
            ConstantNode temp = new ConstantNode(h.matchAndRemove(Token.Type.NUMBER).get());
            return Optional.of(temp);
        }
        else if (h.peek().get().getType() == Token.Type.PATTERN){
            //throw new Exception("It was doing pattern, suck it ");
            PatternNode temp = new PatternNode(h.matchAndRemove(Token.Type.PATTERN).get());
            return Optional.of(temp);
        }
        // We can use match and remove for the rest.
        // The nested functions are a bit different in that we are calling parse operation (kinda) recursivly
        else if (h.matchAndRemove(Token.Type.LPAREN).isPresent()){
            Optional<Node> temp = parseOperation();

            if (h.matchAndRemove(Token.Type.RPAREN).isEmpty())
                throw new Exception("Expected a ')' at " + h.getErrorPosition());
            // Don't need to put this one in an Optional because parseOperation already does that for us.
            return temp;
        }
        else if (h.matchAndRemove(Token.Type.NOT).isPresent()){
            OperationNode temp = new OperationNode(parseOperation().get(), OperationNode.Operation.NOT);
            return Optional.of(temp);
        }
        else if (h.matchAndRemove(Token.Type.MINUS).isPresent()){
            OperationNode temp = new OperationNode(parseOperation().get(), OperationNode.Operation.UNARYNEG);
            return Optional.of(temp);
        }
        else if (h.matchAndRemove(Token.Type.PLUS).isPresent()){
            OperationNode temp = new OperationNode(parseOperation().get(), OperationNode.Operation.UNARYPOS);
            return Optional.of(temp);
        }
        else if (h.matchAndRemove(Token.Type.PLUSPLUS).isPresent()){
            OperationNode temp = new OperationNode(parseOperation().get(), OperationNode.Operation.PREINC);
            return Optional.of(temp);
        }
        else if (h.matchAndRemove(Token.Type.MINUSMINUS).isPresent()){
            OperationNode temp = new OperationNode(parseOperation().get(), OperationNode.Operation.PREDEC);
            return Optional.of(temp);
        }
        else
            // If it's none of the above, then it must be a variable.
            return parseLValue();
    }

    /**
     * The parseLValue() method.
     * @return A VariableReferenceNode containing a valid variable, array variable, or the outcome of a $ operator.
     * @throws Exception
     */
    private Optional<Node> parseLValue() throws Exception{
        // Checks if there are more tokens.
        if (h.moreTokens()){
            // If it is a dollar, pass it to parseBottomLevel()
            if(h.matchAndRemove(Token.Type.DOLLAR).isPresent()){
                OperationNode temp = new OperationNode(parseBottomLevel().get(), OperationNode.Operation.DOLLAR);
                return Optional.of(temp);
            }
            // if its not a dollar, check the next token without eating it.
            Optional<Token> next = h.peek();
            if (next.get().getType() == Token.Type.WORD){
                // Get the next word and sotore as the name
                String name = h.matchAndRemove(Token.Type.WORD).get().getValue();
                // Check for array entry and parse with parseOperation().
                if(h.matchAndRemove(Token.Type.LSQUARE).isPresent()){
                    Optional<Node> index = parseOperation();
                    // If there's no closing bracket, thow a fit.
                    if (h.matchAndRemove(Token.Type.RSQUARE).isEmpty())
                        throw new Exception("Expected a ']' near " + name + " after " + h.getErrorPosition() + ".");
                    
                    VariableReferenceNode temp = new VariableReferenceNode(name, index.get());
                    return Optional.of(temp);
                }
                else{
                    VariableReferenceNode temp = new VariableReferenceNode(name);
                    return Optional.of(temp);
                }
            }
            else 
                throw new Exception("Expected a variable after " + h.getErrorPosition());
        }
        else
            throw new Exception("Expected a token after " + h.getErrorPosition());
    }
}